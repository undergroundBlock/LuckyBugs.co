// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TicketMarketplace {
    address private owner;//             ___  
    address private managingContract; //__&__\\
    // gas efficient shma gas efficient \*_*/
    uint256 public ticketPrice;
    uint256 public societyBalance;
    uint256 public taxPercentage = 21;
    uint256 public constant initialPrice = 0.007 ether;
    uint256 public constant maxTickets = 10000;
    uint256 public trades;

    mapping(uint256 => address) private traderId;
    mapping(address => bool) private traders;
    mapping(address => uint256) public balances;

    uint256 ticketCount;
    mapping(uint => Ticket) public tickets;

    struct Ticket {
        uint id;
        uint price;
        address payable owner;
        bool purchased;
        bool forsale;
    }

    event TicketCreated(
        uint id,
        uint price,
        address payable owner,
        bool purchased
    );

    event TicketPurchased(
        uint id,
        uint price,
        address payable owner,
        bool purchased
    );
    event TicketUnlisted(address seller, uint256 ticketId );

    event TicketListed(address seller, uint256 ticketId, uint256 price);
    
    bool internal locked;

    constructor() {
        owner = msg.sender;
        locked = false;
        managingContract = owner;
        ticketPrice = initialPrice;
    }
    
    modifier noReentrant() {
        require(!locked, "No re-entrancy");
        locked = true;
        _;
        locked = false;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Only the contract owner can call this function.");
        _;
    }

    function createTicket() public  {
        require(ticketPrice > 0);
        ticketCount++;

        tickets[ticketCount] = Ticket({
            id: ticketCount,
            price: ticketPrice,
            owner: payable(msg.sender),
            purchased: false,
            forsale: true
        });

        emit TicketCreated({
            id: ticketCount,
            price: ticketPrice,
            owner: payable(msg.sender),
            purchased: true
        });

        ticketPrice += initialPrice;
        
    }

    function createTickets(uint256 amount) external onlyOwner {
        uint256 a = ticketCount + amount; 
        for (uint256 i = ticketCount; i < a; i++) {
            uint256 ticketId = i;
            require(ticketId >= 1 && ticketId <= maxTickets, "Invalid ticket ID.");
            
            createTicket();
        }
    }

    function purchaseTicket(uint _id) public payable noReentrant {
    
        Ticket memory _ticket = tickets[_id];
        address payable _seller = _ticket.owner;
        require(_ticket.id > 0 && _ticket.id <= ticketCount, "Invalid ticket ID.");
        require(msg.value >= _ticket.price, "Insufficient funds.");
        require(_ticket.forsale, "Ticket not available for sale.");
        require(_seller != msg.sender, "You cannot buy your own ticket.");
        // require( != owner);

        uint256 taxAmount = (_ticket.price * taxPercentage) / 100; 
        uint256 purchaseValue = _ticket.price - taxAmount; 

        if(!traders[msg.sender]){
            trades++;
            traders[msg.sender] = true;
            traderId[trades];
        }
        
        _ticket.forsale = false;
        _ticket.owner = payable(msg.sender);

        // transfer
        if(_ticket.purchased){
            _seller.transfer(purchaseValue);
            uint256 taxAmount2 = (taxAmount * 21) / 100; 
            societyBalance += taxAmount - taxAmount2;
            balances[owner] += taxAmount2;
        } else {
            societyBalance += purchaseValue; 
            balances[owner] += taxAmount;
        }

        _ticket.purchased = true;
        tickets[_id] = _ticket;

        if (msg.value > _ticket.price) {
            uint256 refundAmount = msg.value - _ticket.price;
            payable(msg.sender).transfer(refundAmount);
        } 

        emit TicketPurchased({
            id: ticketCount,
            price: _ticket.price,
            owner: payable(msg.sender),
            purchased: true
        });
    }



    // event TicketPurchased(address buyer, uint256 ticketId, uint256 price);

    

    function setTax(uint256 tax) public onlyOwner {
        require(tax <= 21);
        taxPercentage = tax;
    }

    function setManagingContract(address managingAddress) public onlyOwner {
        managingContract = managingAddress;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        owner = newOwner;
    }

    function sendToManagingContract() public onlyOwner noReentrant {
        require(address(this).balance >= societyBalance);
        payable(managingContract).transfer(societyBalance - 0.1 ether);
        societyBalance = 0.1 ether;
    }

    function withdrawFunds() external payable noReentrant {
        uint256 balance = balances[msg.sender];
        require(balance > 0, "No funds available for withdrawal.");
        balances[msg.sender] = 0;
        payable(msg.sender).transfer(balance);
    }
    
    
    function listTicket(uint256 ticketId, uint256 price) external noReentrant {
        require(ticketId >= 1 && ticketId <= maxTickets, "Invalid ticket ID.");
        Ticket memory ticket = tickets[ticketId];
        require(ticket.purchased, "You can only list vailed ticket's");
        require(ticket.owner == msg.sender, "You can only list your own tickets.");
        require(!ticket.forsale, "Ticket already listed for sale.");
        ticket.forsale = true;
        ticket.price = price;
        tickets[ticketId] = ticket;

        emit TicketListed(msg.sender, ticketId, price);
    }

    function unlistTicket(uint256 ticketId) external noReentrant {
        require(ticketId >= 1 && ticketId <= maxTickets, "Invalid ticket ID.");
        require(tickets[ticketId].owner == msg.sender, "You can only unlist your own tickets.");
        require(tickets[ticketId].forsale, "Ticket is not listed for sale.");
        
        tickets[ticketId].forsale = false;

        emit TicketUnlisted(msg.sender, ticketId);
    }

    
}





